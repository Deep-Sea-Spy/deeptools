[
["index.html", "Report on image analysis Chapter 1 Prerequisites 1.1 Install local package {deeptools}", " Report on image analysis ThinkR 2019-02-04 Chapter 1 Prerequisites 1.1 Install local package {deeptools} remotes::install_local(&quot;deeptools_0.0.2.tar.gz&quot;) "],
["general-exploration-of-the-data.html", "Chapter 2 General exploration of the data 2.1 Packages 2.2 Colours 2.3 Load data 2.4 Prepare data 2.5 percentage participation (part) 2.6 Number of participants per number of image annotated 2.7 Number of images annotated by participant 2.8 Number of time an image was annotated 2.9 Other tops in images in ONC 2.10 Exploration of userlevel in ONC", " Chapter 2 General exploration of the data 2.1 Packages library(dplyr) library(lubridate) library(tidyr) library(ggplot2) # devtools::install_github(&quot;r-spatial/sf&quot;) library(sf) library(raster) library(fasterize) library(igraph) library(rasterVis) library(cowplot) library(deeptools) # devtools::document() # devtools::document() # devtools::load_all(here::here(&quot;&quot;)) 2.2 Colours blue &lt;- &quot;#093564&quot; yellow &lt;- &quot;#efcc26&quot; grey &lt;- &quot;#675546&quot; 2.3 Load data # load data export_file &lt;- system.file(&quot;data_orig/export_last.csv&quot;, package = &quot;deeptools&quot;) liste_photo &lt;- system.file(&quot;data_orig/liste_photo.txt&quot;, package = &quot;deeptools&quot;) 2.4 Prepare data Cleaning of species names to be easily usable Add user_id combining username and date of image analysis just in case a user sees the same image two times. mission2 &lt;- readr::read_csv(export_file) %&gt;% dplyr::select(-comment) %&gt;% tidyr::extract(name, into = &quot;datetime&quot;, regex = &quot;_([[:digit:]]+).&quot;, remove = FALSE ) %&gt;% mutate(datetime = ymd_hms(datetime, tz = &quot;UTC&quot;)) %&gt;% # clean names of species mutate(name_fr_clean = thinkr::clean_vec(name_fr, unique = FALSE)) %&gt;% group_by(username) %&gt;% mutate( user_id = paste(username, as.character(as.numeric(as.factor(datDeb))), sep = &quot;-&quot;) ) %&gt;% ungroup() ## Parsed with column specification: ## cols( ## id = col_integer(), ## image_id = col_integer(), ## name = col_character(), ## username = col_character(), ## userlevel = col_integer(), ## comment = col_character(), ## datDeb = col_datetime(format = &quot;&quot;), ## datFin = col_datetime(format = &quot;&quot;), ## obs_code = col_character(), ## name_fr = col_character(), ## pos1x = col_integer(), ## pos1y = col_integer(), ## pos2x = col_integer(), ## pos2y = col_integer(), ## length = col_integer(), ## middle_x = col_integer(), ## middle_y = col_integer(), ## polygon_values = col_character() ## ) ## Warning in rbind(names(probs), probs_f): number of columns of result is not ## a multiple of vector length (arg 1) ## Warning: 305088 parsing failures. ## row # A tibble: 5 x 5 col row col expected actual file expected &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; actual 1 100288 pos2x an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… file 2 100288 pos2y an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… row 3 100288 length an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… col 4 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… expected 5 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… ## ... ................. ... ........................................................................... ........ ........................................................................... ...... ........................................................................... .... ........................................................................... ... ........................................................................... ... ........................................................................... ........ ........................................................................... ## See problems(...) for more details. # Separate observatory dataset mission2_MAR &lt;- mission2 %&gt;% filter(obs_code == &quot;MAR&quot;) mission2_ONC &lt;- mission2 %&gt;% filter(obs_code == &quot;JDF&quot;) 2.5 percentage participation (part) part &lt;- mission2 %&gt;% count(username) %&gt;% mutate(perc = n * 100 / sum(n)) %&gt;% rlang::set_names(c(&quot;UserID&quot;, &quot;nb_annotations&quot;, &quot;percentage&quot;)) %&gt;% arrange(desc(nb_annotations)) %&gt;% mutate(sumcum = cumsum(percentage)) # 463 participants part ## # A tibble: 463 x 4 ## UserID nb_annotations percentage sumcum ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 chipiok 81521 51.4 51.4 ## 2 grillus33 10952 6.90 58.3 ## 3 Pierre 5250 3.31 61.6 ## 4 classe 3769 2.38 64.0 ## 5 fetescience 3334 2.10 66.1 ## 6 tiffk67 3231 2.04 68.1 ## 7 Audrette 2484 1.57 69.7 ## 8 Kazu 2211 1.39 71.1 ## 9 macrobrachium 2098 1.32 72.4 ## 10 Steatoda 1699 1.07 73.4 ## # … with 453 more rows 2.6 Number of participants per number of image annotated nb_annot_part &lt;- part %&gt;% group_by(nb_annotations) %&gt;% summarize(Nb_participants = n()) %&gt;% arrange(desc(nb_annotations)) %&gt;% mutate(sumcum = cumsum(Nb_participants)) nb_annot_part ## # A tibble: 170 x 3 ## nb_annotations Nb_participants sumcum ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 81521 1 1 ## 2 10952 1 2 ## 3 5250 1 3 ## 4 3769 1 4 ## 5 3334 1 5 ## 6 3231 1 6 ## 7 2484 1 7 ## 8 2211 1 8 ## 9 2098 1 9 ## 10 1699 1 10 ## # … with 160 more rows # Without Chipiok (58552 annotations) part2 &lt;- part[-1, 1:3] part2$sumcum &lt;- cumsum(part2$percentage) 2.7 Number of images annotated by participant ## Number of images annotated by participant## nb_image_part &lt;- mission2 %&gt;% dplyr::select(image_id, username) %&gt;% distinct() %&gt;% count(username) %&gt;% arrange(desc(n)) nb_image_part ## # A tibble: 463 x 2 ## username n ## &lt;chr&gt; &lt;int&gt; ## 1 chipiok 2338 ## 2 grillus33 1019 ## 3 Audrette 570 ## 4 classe 499 ## 5 tiffk67 496 ## 6 fetescience 409 ## 7 Kazu 343 ## 8 Steatoda 335 ## 9 Pierre 306 ## 10 Azaldar 273 ## # … with 453 more rows 2.8 Number of time an image was annotated ## Number of time an image was annotated ---- nb_part_image &lt;- mission2 %&gt;% dplyr::select(image_id, username) %&gt;% distinct() %&gt;% dplyr::count(image_id) %&gt;% arrange(desc(n)) freq_dis &lt;- nb_part_image %&gt;% count(n) %&gt;% rename(n_annotation = n, n_images = nn) freq_dis ## # A tibble: 6 x 2 ## n_annotation n_images ## &lt;int&gt; &lt;int&gt; ## 1 1 182 ## 2 2 449 ## 3 3 1273 ## 4 4 1897 ## 5 5 135 ## 6 6 1 histogram # histogram ggplot(nb_part_image, aes(n)) + geom_bar(fill = yellow, colour = grey) + theme_bw() + xlab(&quot;Number of times an image was annotated&quot;) + ylab(&quot;Number of images&quot;) + ggtitle(&quot;Image annotations&quot;) + theme(panel.background = element_rect(fill = blue)) 2.9 Other tops in images in ONC # Top animal mission2_ONC %&gt;% group_by(name_fr_clean) %&gt;% summarise(n_images = length(unique(image_id))) %&gt;% arrange(desc(n_images)) ## # A tibble: 8 x 2 ## name_fr_clean n_images ## &lt;chr&gt; &lt;int&gt; ## 1 escargot_buccinide 3251 ## 2 vers_polynoides 2099 ## 3 crabe_araignee 2032 ## 4 pycnogonide 2028 ## 5 couverture_vers_tubicole 1385 ## 6 poisson_zoarcide 1361 ## 7 ver_polynoide 636 ## 8 couverture_microbienne 68 # Top user mission2_ONC %&gt;% group_by(username) %&gt;% summarise(n_images = length(unique(image_id))) %&gt;% arrange(desc(n_images)) ## # A tibble: 458 x 2 ## username n_images ## &lt;chr&gt; &lt;int&gt; ## 1 chipiok 2106 ## 2 grillus33 844 ## 3 Audrette 516 ## 4 classe 467 ## 5 tiffk67 429 ## 6 fetescience 370 ## 7 Kazu 303 ## 8 Steatoda 303 ## 9 Pierre 259 ## 10 Azaldar 238 ## # … with 448 more rows # Top image mission2_ONC %&gt;% group_by(image_id) %&gt;% summarise(n_users = length(unique(username))) %&gt;% arrange(desc(n_users)) ## # A tibble: 3,392 x 2 ## image_id n_users ## &lt;int&gt; &lt;int&gt; ## 1 12755 6 ## 2 10700 5 ## 3 10705 5 ## 4 10707 5 ## 5 10758 5 ## 6 10759 5 ## 7 10829 5 ## 8 10843 5 ## 9 10883 5 ## 10 10911 5 ## # … with 3,382 more rows 2.10 Exploration of userlevel in ONC 2.10.1 Userlevel: username == &quot;chipiok&quot; mission2_ONC %&gt;% filter(username == &quot;chipiok&quot;) %&gt;% group_by(datDeb) %&gt;% summarize(userlevel = mean(userlevel)) %&gt;% ggplot() + geom_line(aes(datDeb, userlevel), colour = yellow, size = 2) + theme_bw() + theme(panel.background = element_rect(fill = blue)) + ggtitle(&quot;Evolution of level for user &#39;Chipiok&#39;&quot;) + ylab(&quot;User level&quot;) + xlab(NULL) "],
["exploration-of-buccinide-data.html", "Chapter 3 Exploration of “Buccinide” data 3.1 Packages 3.2 Colours 3.3 Load data 3.4 Prepare data 3.5 Extraction of “Buccinide” 3.6 Exploration of annotations 3.7 Compare annotations of the same image 3.8 Calculate statistics on images 3.9 Estimate average size of individuals", " Chapter 3 Exploration of “Buccinide” data 3.1 Packages library(dplyr) library(lubridate) library(tidyr) library(ggplot2) # devtools::install_github(&quot;r-spatial/sf&quot;) library(sf) library(raster) library(fasterize) library(igraph) library(rasterVis) library(cowplot) library(deeptools) # devtools::document() # devtools::document() # devtools::load_all(here::here(&quot;&quot;)) 3.2 Colours blue &lt;- &quot;#093564&quot; yellow &lt;- &quot;#efcc26&quot; grey &lt;- &quot;#675546&quot; 3.3 Load data # load data export_file &lt;- system.file(&quot;data_orig/export_last.csv&quot;, package = &quot;deeptools&quot;) liste_photo &lt;- system.file(&quot;data_orig/liste_photo.txt&quot;, package = &quot;deeptools&quot;) 3.4 Prepare data Cleaning of species names to be easily usable Add user_id combining username and date of image analysis just in case a user sees the same image two times. mission2 &lt;- readr::read_csv(export_file) %&gt;% dplyr::select(-comment) %&gt;% tidyr::extract(name, into = &quot;datetime&quot;, regex = &quot;_([[:digit:]]+).&quot;, remove = FALSE ) %&gt;% mutate(datetime = ymd_hms(datetime, tz = &quot;UTC&quot;)) %&gt;% # clean names of species mutate(name_fr_clean = thinkr::clean_vec(name_fr, unique = FALSE)) %&gt;% group_by(username) %&gt;% mutate( user_id = paste(username, as.character(as.numeric(as.factor(datDeb))), sep = &quot;-&quot;) ) %&gt;% ungroup() #&gt; Parsed with column specification: #&gt; cols( #&gt; id = col_integer(), #&gt; image_id = col_integer(), #&gt; name = col_character(), #&gt; username = col_character(), #&gt; userlevel = col_integer(), #&gt; comment = col_character(), #&gt; datDeb = col_datetime(format = &quot;&quot;), #&gt; datFin = col_datetime(format = &quot;&quot;), #&gt; obs_code = col_character(), #&gt; name_fr = col_character(), #&gt; pos1x = col_integer(), #&gt; pos1y = col_integer(), #&gt; pos2x = col_integer(), #&gt; pos2y = col_integer(), #&gt; length = col_integer(), #&gt; middle_x = col_integer(), #&gt; middle_y = col_integer(), #&gt; polygon_values = col_character() #&gt; ) #&gt; Warning in rbind(names(probs), probs_f): number of columns of result is not #&gt; a multiple of vector length (arg 1) #&gt; Warning: 305088 parsing failures. #&gt; row # A tibble: 5 x 5 col row col expected actual file expected &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; actual 1 100288 pos2x an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… file 2 100288 pos2y an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… row 3 100288 length an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… col 4 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… expected 5 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… #&gt; ... ................. ... ........................................................................... ........ ........................................................................... ...... ........................................................................... .... ........................................................................... ... ........................................................................... ... ........................................................................... ........ ........................................................................... #&gt; See problems(...) for more details. # Separate observatory dataset mission2_MAR &lt;- mission2 %&gt;% filter(obs_code == &quot;MAR&quot;) mission2_ONC &lt;- mission2 %&gt;% filter(obs_code == &quot;JDF&quot;) 3.5 Extraction of “Buccinide” Function to_carto extract and transform data as spatial object for following analyses. # Filter on Buccinide only ONC2_bucc &lt;- mission2_ONC %&gt;% filter(name_fr_clean == &quot;escargot_buccinide&quot;) # Filter and transform as spatial data ONC2_bucc_carto &lt;- mission2_ONC %&gt;% to_carto(name_fr_clean, &quot;escargot_buccinide&quot;) 3.6 Exploration of annotations 3.6.1 Users ONC2_bucc %&gt;% count(username) %&gt;% arrange(desc(n)) #&gt; # A tibble: 453 x 2 #&gt; username n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 chipiok 14183 #&gt; 2 grillus33 5230 #&gt; 3 tiffk67 2534 #&gt; 4 classe 2057 #&gt; 5 Audrette 1917 #&gt; 6 Kazu 1819 #&gt; 7 fetescience 1731 #&gt; 8 Steatoda 1516 #&gt; 9 Pierre 1367 #&gt; 10 Azaldar 1231 #&gt; # … with 443 more rows 3.6.2 Images ONC2_bucc %&gt;% count(image_id) %&gt;% arrange(desc(n)) #&gt; # A tibble: 3,251 x 2 #&gt; image_id n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 11873 101 #&gt; 2 11201 88 #&gt; 3 10747 86 #&gt; 4 11383 86 #&gt; 5 12794 85 #&gt; 6 12783 83 #&gt; 7 12200 82 #&gt; 8 11830 80 #&gt; 9 11379 79 #&gt; 10 11947 78 #&gt; # … with 3,241 more rows 3.6.3 Example: filter_col = username, filter_val = &quot;Lawzama&quot;, image_id == &quot;10681&quot; #&gt; # A tibble: 115 x 2 #&gt; image_id n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 12860 12 #&gt; 2 10957 10 #&gt; 3 12568 10 #&gt; 4 10853 9 #&gt; 5 11704 8 #&gt; 6 12350 8 #&gt; 7 10821 7 #&gt; 8 11383 7 #&gt; 9 11517 7 #&gt; 10 11705 7 #&gt; # … with 105 more rows 3.6.4 Example: filter_col = username, filter_val = &quot;Kazu&quot;, image_id == &quot;10681&quot; gg_users_image(x = ONC2_bucc_carto, filter_col = username, filter_val = &quot;Kazu&quot;, image_id = 10681) 3.6.5 Example: filter_col = username, filter_val = c(&quot;Kazu&quot;, &quot;Lawzama&quot;), image_id == &quot;10681&quot; gg_users_image(x = ONC2_bucc_carto, filter_col = username, filter_val = c(&quot;Kazu&quot;, &quot;Lawzama&quot;), image_id = 10681) 3.7 Compare annotations of the same image 3.7.1 Super-impose annotations This allows to check visually what sizes of buffer we can use to determine animals discovered by two persons. # Number of animals seen on the image by username ONC2_bucc %&gt;% filter(image_id == 10681) %&gt;% count(user_id) #&gt; # A tibble: 4 x 2 #&gt; user_id n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Audrette-483 8 #&gt; 2 Kazu-100 19 #&gt; 3 Lawzama-37 2 #&gt; 4 Maguelone-47 10 gg_users_image(x = ONC2_bucc_carto, image_id = 10681, buffer = 10) 3.7.2 Find common animals between users 3.7.2.1 Method detailed These steps do not have to be run as they are included in find_groups_in_image function presented below. These steps are here to explain the method. To compute statistics on individuals on images, it is important to know if different users found the same individuals. There is a variability in positioning individuals. Hence, to find out common individuals between users, we need to look in the neighborhood. A quick exploration suggests a buffer area of 10 pixels could be enough for finding overlapping annotations. The following steps are here to detail the complete process, but at the end, they are all included in a unique fonction find_commons. Note that functions are adapted to the structure of the examle dataset, included column names. For each image steps are: Create Voronoi polygons around sf features by user_id. Voronoi is necessary to get non overlapping buffer areas of too close individuals. This also allows for super-imposed individuals. Crop Voronoi with buffer area. This avoids to look in a too far neighborhood. Transform Voronoi as raster by user_id. Transforming polygons into pixels allow to find out the most overlapping groups of polygons among users. Stack all rasters by image_id # Choose one image for one user image_id &lt;- &quot;10681&quot; user_id &lt;- &quot;Kazu-100&quot; bucc_image_user &lt;- ONC2_bucc_carto %&gt;% dplyr::filter(image_id == !!image_id, user_id == !!user_id) r_image &lt;- raster(bucc_image_user, res = 0.5) dist_buffer &lt;- 10 # Calculate voronoi for one user_id image_user_intermediates &lt;- voronoi_rasterize( x = bucc_image_user, dist_buffer = dist_buffer, r_image = r_image, keep_intermediate = TRUE) #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries # Show intermediate steps p1 &lt;- ggplot(image_user_intermediates$points_in_voronoi) + geom_sf(aes(fill = image_pol_id)) + geom_sf(data = st_cast(st_geometry(bucc_image_user), &quot;POINT&quot;), size = 0.25) + theme_images(x = image_user_intermediates$points_in_voronoi, fill = &quot;c&quot;, color = NULL) p2 &lt;- ggplot(image_user_intermediates$points_in_voronoi_in_buffer) + geom_sf(aes(fill = image_pol_id)) + geom_sf(data = st_cast(st_geometry(bucc_image_user), &quot;POINT&quot;), size = 0.25) + theme_images(x = image_user_intermediates$points_in_voronoi, fill = &quot;c&quot;, color = NULL) p3 &lt;- gplot(image_user_intermediates$voronoi_in_buffer_as_raster) + geom_tile(aes(fill = value)) + theme_images(x = image_user_intermediates$points_in_voronoi, fill = &quot;c&quot;, color = NULL, na.value = NA) cowplot::plot_grid(plotlist = list(p1, p2, p3), ncol = 3) The above intermediate steps are included in the voronoi_stacker function, which stacks rasters of all user_id. image_id &lt;- &quot;10681&quot; bucc_image &lt;- ONC2_bucc_carto %&gt;% dplyr::filter(image_id == !!image_id) r_image &lt;- raster(bucc_image, res = 0.5) dist_buffer &lt;- 15 bucc_voronoi_stack &lt;- voronoi_stacker(x = bucc_image, dist_buffer = dist_buffer, r_image = r_image) #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries gplot(bucc_voronoi_stack) + geom_tile(aes(fill = value)) + facet_wrap(~variable) + theme_images(x = image_user_intermediates$points_in_voronoi, fill = &quot;c&quot;, color = NULL, na.value = NA) + ggtitle(&quot;Pixels numbered according to marked individuals&quot;) For each pixel of the stack, we can define a group of polygons with the same size as the number of user_id. Indeed, an important part of pixels are not covered by polygons and will be identified as NA-...-NA-...-NA. Once removed those pixels, we can find the most represented groups of polygons. # Combine layers and find groups of polygons bucc_groups_count &lt;- group_pixels_count(bucc_voronoi_stack) bucc_groups_count #&gt; # A tibble: 86 x 2 #&gt; grouped_ids n_pixels #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 13-20-22-39 7614 #&gt; 2 6-NA-NA-NA 7388 #&gt; 3 NA-NA-NA-34 7172 #&gt; 4 10-NA-26-33 6765 #&gt; 5 1-21-29-30 6583 #&gt; 6 NA-NA-27-NA 6459 #&gt; 7 5-NA-NA-NA 6374 #&gt; 8 3-NA-NA-NA 5492 #&gt; 9 12-NA-24-37 5464 #&gt; 10 14-NA-NA-NA 5141 #&gt; # … with 76 more rows Problem is that some polygons are in more or less big groups, sometimes being in combination with two different polygons of the same user. We need to find out the best combinations of polygons to associate them to individuals really appearing on the original images. In step 1, for each polygon independently: Choose group when associated to maximum other polygons Choose group with highest surface in common With these two rules, some chosen groups may include polygons associated to other groups. #&#39; Find in which groups are each polygons all_image_pol_ids &lt;- pull(bucc_image, image_pol_id) %&gt;% unique() bucc_groups_top &lt;- find_top_groups(bucc_groups_count, all_image_pol_ids) test_ids_in_group &lt;- test_groups_kept(bucc_groups_top) # Show in how many groups are individuals (Should be only one) test_ids_in_group$ids_in_groups_count #&gt; # A tibble: 39 x 2 #&gt; list_ids n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 32 2 #&gt; 2 1 1 #&gt; 3 2 1 #&gt; 4 3 1 #&gt; 5 4 1 #&gt; 6 5 1 #&gt; 7 6 1 #&gt; 8 7 1 #&gt; 9 8 1 #&gt; 10 9 1 #&gt; # … with 29 more rows It is necessary to create a loop to reduce grouping possibilities based on same rules. In step two, for each image_pol_id found in multiple groups, keep the only group following the above two rules. Others are removed from list of possibilities. Step one is run again without these groups. Run these two steps until each polygon is found in one and only one group. If an image_pol_id has no group left, it is included in a group alone # If image_pol_ids are not unique reduce possibilities until it is good if (test_ids_in_group$max_groups &gt; 1) { # Run again group selection while removing groups with problems # _Find groups to remove test_ids_in_group2 &lt;- test_ids_in_group bucc_groups_top2 &lt;- bucc_groups_top group_remove2 &lt;- NULL while (test_ids_in_group2$max_groups &gt; 1) { group_remove &lt;- test_ids_in_group2$ids_in_groups_count %&gt;% filter(n &gt; 1) %&gt;% inner_join(test_ids_in_group2$ids_in_groups, by = &quot;list_ids&quot;) %&gt;% inner_join(bucc_groups_top2, by = &quot;group_kept&quot;) %&gt;% dplyr::select(-image_pol_id) %&gt;% distinct() %&gt;% group_by(list_ids) %&gt;% arrange(desc(n_pols), desc(n_pixels)) %&gt;% slice(-1) %&gt;% pull(group_kept) %&gt;% unique() group_remove2 &lt;- unique(c(group_remove2, group_remove)) bucc_groups_top2 &lt;- bucc_groups_count %&gt;% filter(!grouped_ids %in% group_remove2) %&gt;% find_top_groups(all_ids = all_image_pol_ids) # bucc_groups_top2 %&gt;% filter(grepl(7, group_kept)) # bucc_groups_top2 %&gt;% filter(grepl(32, group_kept)) test_ids_in_group2 &lt;- test_groups_kept(bucc_groups_top2) } # Retrieve success grouping bucc_groups_top &lt;- bucc_groups_top2 # Last verification test_ids_in_group &lt;- test_groups_kept(bucc_groups_top) } # Show in how many groups are individuals (Should be only one) test_ids_in_group$ids_in_groups_count #&gt; # A tibble: 39 x 2 #&gt; list_ids n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 3 1 #&gt; 4 4 1 #&gt; 5 5 1 #&gt; 6 6 1 #&gt; 7 7 1 #&gt; 8 8 1 #&gt; 9 9 1 #&gt; 10 10 1 #&gt; # … with 29 more rows 3.7.2.2 Function: Find groups in one image The above procedure is included in a unique function available for a unique image: find_groups_in_image(x, image_id) which adds the group name to the original dataset. We can then verify the grouping procedure visually. # Add group names in image_sf bucc_image_grouped &lt;- ONC2_bucc_carto %&gt;% find_groups_in_image(image_id = &quot;10681&quot;) #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries #&gt; Warning: attribute variables are assumed to be spatially constant #&gt; throughout all geometries # Create specific image with group names bucc_image_grouped_groups &lt;- bucc_image_grouped %&gt;% group_by(group_kept) %&gt;% summarize() %&gt;% st_centroid() %&gt;% cbind(st_coordinates(.)) #&gt; Warning in st_centroid.sf(.): st_centroid assumes attributes are constant #&gt; over geometries of x ggplot(bucc_image_grouped %&gt;% mutate(group_kept = forcats::fct_reorder(group_kept, desc(n_pols))) ) + geom_sf(aes(color = group_kept), show.legend = &quot;line&quot;, size = 2 #alpha = 0.1 ) + ggrepel::geom_text_repel( data = bucc_image_grouped_groups, aes(x = X, y = Y, label = group_kept)) + theme_images(x = bucc_image_grouped, fill = NULL, color = &quot;d&quot;, na.value = &quot;grey20&quot;) + guides(color = FALSE) + ggtitle(&quot;Identification of groups of marked individuals&quot;) 3.7.3 Find all groups for all images Everything can be included in a unique function find_groups_in_all_images to explore the entire dataset at once. This takes some time and some place: ~30min on dual core Be sure to have at least 10Go RAM available, otherwise use find_groups_in_image iteratively in a loop for instance. # Chunk not evaluated in Rmd as results are saved ONC2_bucc_carto_groups &lt;- find_groups_in_all_images(ONC2_bucc_carto, .progress = TRUE, keep_list = FALSE, as_sf = FALSE) if (!dir.exists(here::here(&quot;inst/outputs&quot;))) { dir.create(&quot;inst/outputs&quot;, recursive = TRUE) } readr::write_rds( ONC2_bucc_carto_groups, here::here(&quot;inst/outputs&quot;, &quot;ONC2_bucc_carto_groups.rds&quot;), compress = &quot;gz&quot;) outwd &lt;- system.file(&quot;outputs&quot;, package = &quot;deeptools&quot;) ONC2_bucc_carto_groups &lt;- readr::read_rds(file.path(outwd, &quot;ONC2_bucc_carto_groups.rds&quot;)) 3.8 Calculate statistics on images As a reminder, a group of objects is supposed to be a unique individual. 3.8.1 Number of objects per image (already known before) # ONC2_bucc_carto_groups # Number of objects per image (already known before) bucc_nobjects &lt;- ONC2_bucc_carto_groups %&gt;% count(image_id) %&gt;% rename(n_objects = n) %&gt;% count(n_objects) %&gt;% arrange(desc(n)) %&gt;% rename(n_images = n) # Number of marked objects by images bucc_nobjects #&gt; # A tibble: 86 x 2 #&gt; n_objects n_images #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4 228 #&gt; 2 6 187 #&gt; 3 8 185 #&gt; 4 5 175 #&gt; 5 7 162 #&gt; 6 9 161 #&gt; 7 12 149 #&gt; 8 10 142 #&gt; 9 3 139 #&gt; 10 11 102 #&gt; # … with 76 more rows # Plot ggplot(bucc_nobjects) + geom_col(aes(x = n_objects, y = n_images), width = 1, fill = yellow, colour = grey) + ggtitle(&quot;Total number of objects identified in images&quot;) + xlab(&quot;Number of objects by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) 3.8.2 Statistics on groups Calculate the number of users who marked the same individual. The proportion column can be used as a threshold to decide if the individual is kept. Indeed, an individual observed by only one of the users may not be a real individual. # Stats on groups bucc_groups &lt;- ONC2_bucc_carto_groups %&gt;% group_by(image_id, group_kept) %&gt;% summarise( n_users = n(), n_user_id = mean(n_user_id), proportion = n()/mean(n_user_id) ) %&gt;% ungroup() # Number of individuals ~ proportion bucc_groups #&gt; # A tibble: 24,272 x 5 #&gt; image_id group_kept n_users n_user_id proportion #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 10680 1-19-NA-44 3 4 0.75 #&gt; 2 10680 10-NA-NA-NA 1 4 0.25 #&gt; 3 10680 11-NA-NA-NA 1 4 0.25 #&gt; 4 10680 12-NA-NA-NA 1 4 0.25 #&gt; 5 10680 13-26-NA-NA 2 4 0.5 #&gt; 6 10680 14-NA-NA-NA 1 4 0.25 #&gt; 7 10680 2-18-36-43 4 4 1 #&gt; 8 10680 3-23-34-40 4 4 1 #&gt; 9 10680 4-22-33-42 4 4 1 #&gt; 10 10680 5-21-32-39 4 4 1 #&gt; # … with 24,262 more rows # Plot bucc_groups %&gt;% ggplot() + geom_histogram(aes(proportion), bins = 10, fill = yellow, colour = grey) + ggtitle(&quot;Number of individuals ~ proportion&quot;) + xlab(&quot;Proportion of users who identified an individual&quot;) + ylab(&quot;Number of individuals in this case&quot;) + theme(panel.background = element_rect(fill = blue)) 3.8.3 Statistics on number of groups by image Calculate the number of groups in all images. ## Stats on nb groups by image bucc_ngroups_count &lt;- bucc_groups %&gt;% group_by(image_id) %&gt;% summarise(n_groups = n()) # Number of images bucc_ngroups_count %&gt;% count(n_groups) #&gt; # A tibble: 36 x 2 #&gt; n_groups n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 327 #&gt; 2 2 467 #&gt; 3 3 441 #&gt; 4 4 381 #&gt; 5 5 265 #&gt; 6 6 198 #&gt; 7 7 120 #&gt; 8 8 77 #&gt; 9 9 60 #&gt; 10 10 58 #&gt; # … with 26 more rows # Plot ggplot(bucc_ngroups_count) + geom_histogram(aes(x = n_groups), bins = 30, fill = yellow, colour = grey) + ggtitle(&quot;Number of groups (~individuals) in images&quot;) + xlab(&quot;Number of groups by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) If we only keep groups identified by at least half of the users, we can recalculate the number of groups by image. ## Stats on nb groups by image bucc_ngroups_count_thd &lt;- bucc_groups %&gt;% filter(proportion &gt;= 0.5) %&gt;% group_by(image_id) %&gt;% summarise(n_groups = n()) # Number of images bucc_ngroups_count_thd %&gt;% count(n_groups) #&gt; # A tibble: 27 x 2 #&gt; n_groups n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 655 #&gt; 2 2 680 #&gt; 3 3 513 #&gt; 4 4 327 #&gt; 5 5 145 #&gt; 6 6 71 #&gt; 7 7 50 #&gt; 8 8 71 #&gt; 9 9 92 #&gt; 10 10 92 #&gt; # … with 17 more rows # Plot ggplot(bucc_ngroups_count_thd) + geom_histogram(aes(x = n_groups), bins = 30, fill = yellow, colour = grey) + ggtitle(&quot;Number of groups (~individuals) in images&quot;) + xlab(&quot;Groups with proportion &gt;= 0.5 by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) 3.9 Estimate average size of individuals We assume that a group is a unique individual. We also remove groups identified by less than 50% of users. # Mean size of individuals bucc_lengths &lt;- ONC2_bucc_carto_groups %&gt;% left_join(bucc_groups %&gt;% dplyr::select(image_id, group_kept, proportion), by = c(&quot;image_id&quot;, &quot;group_kept&quot;)) %&gt;% filter(proportion &gt;= 0.5) %&gt;% group_by(image_id, group_kept) %&gt;% summarise(mean_length = mean(length)) ggplot(bucc_lengths) + geom_histogram(aes(mean_length), bins = 50, fill = yellow, colour = grey) + scale_x_log10() + theme(panel.background = element_rect(fill = blue)) + ggtitle(&quot;Distribution of lengths of individuals&quot;) + xlab(&quot;Group mean length (log scale)&quot;) + ylab(&quot;Number of individuals&quot;) "],
["exploration-of-pycnogonide-data.html", "Chapter 4 Exploration of “Pycnogonide” data 4.1 Packages 4.2 Colours 4.3 Load data 4.4 Prepare data 4.5 Extraction of “pycnogonide” 4.6 Exploration of annotations 4.7 Find all groups 4.8 Calculate statistics on images", " Chapter 4 Exploration of “Pycnogonide” data 4.1 Packages library(dplyr) library(lubridate) library(tidyr) library(ggplot2) # devtools::install_github(&quot;r-spatial/sf&quot;) library(sf) library(raster) library(fasterize) library(igraph) library(rasterVis) library(cowplot) library(deeptools) # devtools::document() # devtools::document() # devtools::load_all(here::here(&quot;&quot;)) 4.2 Colours blue &lt;- &quot;#093564&quot; yellow &lt;- &quot;#efcc26&quot; grey &lt;- &quot;#675546&quot; 4.3 Load data # load data export_file &lt;- system.file(&quot;data_orig/export_last.csv&quot;, package = &quot;deeptools&quot;) liste_photo &lt;- system.file(&quot;data_orig/liste_photo.txt&quot;, package = &quot;deeptools&quot;) 4.4 Prepare data Cleaning of species names to be easily usable Add user_id combining username and date of image analysis just in case a user sees the same image two times. mission2 &lt;- readr::read_csv(export_file) %&gt;% dplyr::select(-comment) %&gt;% tidyr::extract(name, into = &quot;datetime&quot;, regex = &quot;_([[:digit:]]+).&quot;, remove = FALSE ) %&gt;% mutate(datetime = ymd_hms(datetime, tz = &quot;UTC&quot;)) %&gt;% # clean names of species mutate(name_fr_clean = thinkr::clean_vec(name_fr, unique = FALSE)) %&gt;% group_by(username) %&gt;% mutate( user_id = paste(username, as.character(as.numeric(as.factor(datDeb))), sep = &quot;-&quot;) ) %&gt;% ungroup() #&gt; Parsed with column specification: #&gt; cols( #&gt; id = col_integer(), #&gt; image_id = col_integer(), #&gt; name = col_character(), #&gt; username = col_character(), #&gt; userlevel = col_integer(), #&gt; comment = col_character(), #&gt; datDeb = col_datetime(format = &quot;&quot;), #&gt; datFin = col_datetime(format = &quot;&quot;), #&gt; obs_code = col_character(), #&gt; name_fr = col_character(), #&gt; pos1x = col_integer(), #&gt; pos1y = col_integer(), #&gt; pos2x = col_integer(), #&gt; pos2y = col_integer(), #&gt; length = col_integer(), #&gt; middle_x = col_integer(), #&gt; middle_y = col_integer(), #&gt; polygon_values = col_character() #&gt; ) #&gt; Warning in rbind(names(probs), probs_f): number of columns of result is not #&gt; a multiple of vector length (arg 1) #&gt; Warning: 305088 parsing failures. #&gt; row # A tibble: 5 x 5 col row col expected actual file expected &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; actual 1 100288 pos2x an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… file 2 100288 pos2y an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… row 3 100288 length an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… col 4 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… expected 5 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… #&gt; ... ................. ... ........................................................................... ........ ........................................................................... ...... ........................................................................... .... ........................................................................... ... ........................................................................... ... ........................................................................... ........ ........................................................................... #&gt; See problems(...) for more details. # Separate observatory dataset mission2_MAR &lt;- mission2 %&gt;% filter(obs_code == &quot;MAR&quot;) mission2_ONC &lt;- mission2 %&gt;% filter(obs_code == &quot;JDF&quot;) 4.5 Extraction of “pycnogonide” # Filter on Buccinide only ONC2_pyc &lt;- mission2_ONC %&gt;% filter(name_fr_clean == &quot;pycnogonide&quot;) # Filter and transform as spatial data ONC2_pyc_carto &lt;- mission2_ONC %&gt;% to_carto(name_fr_clean, &quot;pycnogonide&quot;) 4.6 Exploration of annotations 4.6.1 Users ONC2_pyc %&gt;% count(username) %&gt;% arrange(desc(n)) #&gt; # A tibble: 4 x 2 #&gt; username n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 chipiok 45695 #&gt; 2 grillus33 2277 #&gt; 3 fetescience 807 #&gt; 4 classe 672 4.6.2 Images Number of annotations by image ONC2_pyc %&gt;% count(image_id) %&gt;% arrange(desc(n)) #&gt; # A tibble: 2,028 x 2 #&gt; image_id n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 13855 180 #&gt; 2 11725 167 #&gt; 3 13059 165 #&gt; 4 13373 163 #&gt; 5 12571 158 #&gt; 6 13510 150 #&gt; 7 12933 146 #&gt; 8 13578 145 #&gt; 9 12266 135 #&gt; 10 13405 130 #&gt; # … with 2,018 more rows Number of users by image ONC2_pyc %&gt;% group_by(image_id) %&gt;% summarize(n_users = length(unique(user_id))) %&gt;% arrange(desc(n_users)) #&gt; # A tibble: 2,028 x 2 #&gt; image_id n_users #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 11425 4 #&gt; 2 12838 4 #&gt; 3 13988 4 #&gt; 4 10725 3 #&gt; 5 10784 3 #&gt; 6 10785 3 #&gt; 7 10874 3 #&gt; 8 11062 3 #&gt; 9 11083 3 #&gt; 10 11095 3 #&gt; # … with 2,018 more rows 4.6.3 Example: filter_col = username, filter_val = &quot;grillus33&quot;, image_id == &quot;10681&quot; #&gt; # A tibble: 268 x 2 #&gt; image_id n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 12738 46 #&gt; 2 13749 46 #&gt; 3 13059 45 #&gt; 4 12686 42 #&gt; 5 13836 40 #&gt; 6 14075 40 #&gt; 7 12954 39 #&gt; 8 11962 38 #&gt; 9 12024 36 #&gt; 10 13807 34 #&gt; # … with 258 more rows 4.6.4 Multiple users annotations Example with image_id = 11425 gg_users_image(x = ONC2_pyc_carto, image_id = 11425) Comparison with buffer Define a buffer size for future analyses It seems that precision is low for this point identification, then buffer size need to be big gg_users_image(x = ONC2_pyc_carto, image_id = 11425, buffer = 40) 4.7 Find all groups As shown for “Buccinides”, only one function is required to determine the differents groups of annotations in all images. This requires function find_groups_in_all_images, some time of computation and RAM available. # Chunk not evaluated in Rmd as results are saved ONC2_pyc_carto_groups &lt;- find_groups_in_all_images(ONC2_pyc_carto, .progress = TRUE, keep_list = FALSE, as_sf = FALSE, dist_buffer = 40) if (!dir.exists(here::here(&quot;inst/outputs&quot;))) { dir.create(&quot;inst/outputs&quot;, recursive = TRUE) } readr::write_rds( ONC2_pyc_carto_groups, here::here(&quot;inst/outputs&quot;, &quot;ONC2_pyc_carto_groups.rds&quot;), compress = &quot;gz&quot;) outwd &lt;- system.file(&quot;outputs&quot;, package = &quot;deeptools&quot;) ONC2_pyc_carto_groups &lt;- readr::read_rds(file.path(outwd, &quot;ONC2_pyc_carto_groups.rds&quot;)) 4.8 Calculate statistics on images As a reminder, a group of objects is supposed to be a unique individual. 4.8.1 Number of objects per image (already known before) # Number of objects per image (already known before) pyc_nobjects &lt;- ONC2_pyc_carto_groups %&gt;% count(image_id) %&gt;% rename(n_objects = n) %&gt;% count(n_objects) %&gt;% arrange(desc(n)) %&gt;% rename(n_images = n) # Number of marked objects by images pyc_nobjects #&gt; # A tibble: 115 x 2 #&gt; n_objects n_images #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 13 105 #&gt; 2 12 82 #&gt; 3 17 82 #&gt; 4 19 81 #&gt; 5 14 80 #&gt; 6 16 72 #&gt; 7 15 70 #&gt; 8 11 68 #&gt; 9 18 67 #&gt; 10 20 61 #&gt; # … with 105 more rows # Plot ggplot(pyc_nobjects) + geom_col(aes(x = n_objects, y = n_images), width = 1, fill = yellow, colour = grey) + ggtitle(&quot;Total number of objects identified in images&quot;) + xlab(&quot;Number of objects by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) 4.8.2 Statistics on groups Calculate the number of users who marked the same individual. The proportion column can be used as a threshold to decide if the individual is kept. Indeed, an individual observed by only one of the users may not be a real individual. # Stats on groups pyc_groups &lt;- ONC2_pyc_carto_groups %&gt;% group_by(image_id, group_kept) %&gt;% summarise( n_users = n(), n_user_id = mean(n_user_id), proportion = n()/mean(n_user_id) ) %&gt;% ungroup() # Number of individuals ~ proportion pyc_groups #&gt; # A tibble: 44,300 x 5 #&gt; image_id group_kept n_users n_user_id proportion #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 10680 1 1 1 1 #&gt; 2 10680 10 1 1 1 #&gt; 3 10680 11 1 1 1 #&gt; 4 10680 12 1 1 1 #&gt; 5 10680 13 1 1 1 #&gt; 6 10680 14 1 1 1 #&gt; 7 10680 15 1 1 1 #&gt; 8 10680 16 1 1 1 #&gt; 9 10680 17 1 1 1 #&gt; 10 10680 18 1 1 1 #&gt; # … with 44,290 more rows # Plot pyc_groups %&gt;% ggplot() + geom_histogram(aes(proportion), bins = 10, fill = yellow, colour = grey) + ggtitle(&quot;Number of individuals ~ proportion&quot;) + xlab(&quot;Proportion of users who identified an individual&quot;) + ylab(&quot;Number of individuals in this case&quot;) + theme(panel.background = element_rect(fill = blue)) #&gt; Warning: Removed 1 rows containing non-finite values (stat_bin). 4.8.3 Statistics on number of groups by image Calculate the number of groups in all images. ## Stats on nb groups by image pyc_ngroups_count &lt;- pyc_groups %&gt;% group_by(image_id) %&gt;% summarise(n_groups = n()) # Number of images pyc_ngroups_count %&gt;% count(n_groups) #&gt; # A tibble: 100 x 2 #&gt; n_groups n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 32 #&gt; 2 2 40 #&gt; 3 3 28 #&gt; 4 4 37 #&gt; 5 5 35 #&gt; 6 6 46 #&gt; 7 7 45 #&gt; 8 8 48 #&gt; 9 9 60 #&gt; 10 10 54 #&gt; # … with 90 more rows # Plot ggplot(pyc_ngroups_count) + geom_histogram(aes(x = n_groups), bins = 30, fill = yellow, colour = grey) + ggtitle(&quot;Number of groups (~individuals) in images&quot;) + xlab(&quot;Number of groups by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) If we only keep groups identified by at least half of the users, we can recalculate the number of groups by image. ## Stats on nb groups by image pyc_ngroups_count_thd &lt;- pyc_groups %&gt;% filter(proportion &gt;= 0.5) %&gt;% group_by(image_id) %&gt;% summarise(n_groups = n()) # Number of images pyc_ngroups_count_thd %&gt;% count(n_groups) #&gt; # A tibble: 98 x 2 #&gt; n_groups n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 33 #&gt; 2 2 41 #&gt; 3 3 29 #&gt; 4 4 41 #&gt; 5 5 37 #&gt; 6 6 49 #&gt; 7 7 48 #&gt; 8 8 53 #&gt; 9 9 64 #&gt; 10 10 58 #&gt; # … with 88 more rows # Plot ggplot(pyc_ngroups_count_thd) + geom_histogram(aes(x = n_groups), bins = 30, fill = yellow, colour = grey) + ggtitle(&quot;Number of groups (~individuals) in images&quot;) + xlab(&quot;Groups with proportion &gt;= 0.5 by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) "],
["exploration-of-couverture-de-moules-data.html", "Chapter 5 Exploration of “Couverture de moules” data 5.1 Packages 5.2 Colours 5.3 Load data 5.4 Prepare data 5.5 Extraction of “Buccinide” 5.6 Exploration of annotations 5.7 Find all groups 5.8 Calculate statistics on images", " Chapter 5 Exploration of “Couverture de moules” data 5.1 Packages library(dplyr) library(ggplot2) # devtools::install_github(&quot;r-spatial/sf&quot;) library(sf) library(deeptools) library(lubridate) library(thinkr) library(readr) library(tidyr) 5.2 Colours blue &lt;- &quot;#093564&quot; yellow &lt;- &quot;#efcc26&quot; grey &lt;- &quot;#675546&quot; 5.3 Load data # load data export_file &lt;- system.file(&quot;data_orig/export_last.csv&quot;, package = &quot;deeptools&quot;) liste_photo &lt;- system.file(&quot;data_orig/liste_photo.txt&quot;, package = &quot;deeptools&quot;) 5.4 Prepare data Cleaning of species names to be easily usable Add user_id combining username and date of image analysis just in case a user sees the same image two times. mission2 &lt;- read_csv(export_file) %&gt;% dplyr::select(-comment) %&gt;% tidyr::extract(name, into = &quot;datetime&quot;, regex = &quot;_([[:digit:]]+).&quot;, remove = FALSE ) %&gt;% mutate(datetime = ymd_hms(datetime, tz = &quot;UTC&quot;)) %&gt;% # clean names of species mutate(name_fr_clean = clean_vec(name_fr, unique = FALSE)) %&gt;% group_by(username) %&gt;% mutate( user_id = paste(username, as.character(as.numeric(as.factor(datDeb))), sep = &quot;-&quot;) ) %&gt;% ungroup() #&gt; Parsed with column specification: #&gt; cols( #&gt; id = col_integer(), #&gt; image_id = col_integer(), #&gt; name = col_character(), #&gt; username = col_character(), #&gt; userlevel = col_integer(), #&gt; comment = col_character(), #&gt; datDeb = col_datetime(format = &quot;&quot;), #&gt; datFin = col_datetime(format = &quot;&quot;), #&gt; obs_code = col_character(), #&gt; name_fr = col_character(), #&gt; pos1x = col_integer(), #&gt; pos1y = col_integer(), #&gt; pos2x = col_integer(), #&gt; pos2y = col_integer(), #&gt; length = col_integer(), #&gt; middle_x = col_integer(), #&gt; middle_y = col_integer(), #&gt; polygon_values = col_character() #&gt; ) #&gt; Warning in rbind(names(probs), probs_f): number of columns of result is not #&gt; a multiple of vector length (arg 1) #&gt; Warning: 305088 parsing failures. #&gt; row # A tibble: 5 x 5 col row col expected actual file expected &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; actual 1 100288 pos2x an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… file 2 100288 pos2y an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… row 3 100288 length an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… col 4 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… expected 5 100288 middle… an integ… NULL &#39;/usr/local/lib/R/site-library/deeptools… #&gt; ... ................. ... ........................................................................... ........ ........................................................................... ...... ........................................................................... .... ........................................................................... ... ........................................................................... ... ........................................................................... ........ ........................................................................... #&gt; See problems(...) for more details. # Separate observatory dataset mission2_MAR &lt;- mission2 %&gt;% filter(obs_code == &quot;MAR&quot;) mission2_ONC &lt;- mission2 %&gt;% filter(obs_code == &quot;JDF&quot;) 5.5 Extraction of “Buccinide” Function to_carto extract and transform data as spatial object for following analyses. # Filter on Buccinide only MAR_mussel &lt;- mission2_MAR %&gt;% filter(name_fr_clean == &quot;couverture_de_moules&quot;) # Filter and transform as spatial data MAR_mussel_carto &lt;- mission2_MAR %&gt;% filter(name_fr_clean == &quot;couverture_de_moules&quot;) %&gt;% to_carto(name_fr_clean, &quot;couverture_de_moules&quot;) Only because it is nice ggplot(MAR_mussel_carto) + geom_sf(aes(fill = as.character(image_id)), alpha = 0.1) + guides(fill = FALSE) 5.6 Exploration of annotations 5.6.1 Users MAR_mussel %&gt;% count(username) %&gt;% arrange(desc(n)) #&gt; # A tibble: 2 x 2 #&gt; username n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 chipiok 1527 #&gt; 2 grillus33 71 5.6.2 Images Number of annotations by image MAR_mussel %&gt;% count(image_id) %&gt;% arrange(desc(n)) #&gt; # A tibble: 133 x 2 #&gt; image_id n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 14411 32 #&gt; 2 14589 28 #&gt; 3 14186 27 #&gt; 4 14307 25 #&gt; 5 14281 23 #&gt; 6 14326 23 #&gt; 7 14396 21 #&gt; 8 14552 21 #&gt; 9 14352 20 #&gt; 10 14147 19 #&gt; # … with 123 more rows Number of users by image MAR_mussel %&gt;% group_by(image_id) %&gt;% summarize(n_users = length(unique(user_id))) %&gt;% arrange(desc(n_users)) #&gt; # A tibble: 133 x 2 #&gt; image_id n_users #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 14186 2 #&gt; 2 14190 2 #&gt; 3 14281 2 #&gt; 4 14307 2 #&gt; 5 14326 2 #&gt; 6 14329 2 #&gt; 7 14352 2 #&gt; 8 14387 2 #&gt; 9 14396 2 #&gt; 10 14411 2 #&gt; # … with 123 more rows 5.6.3 Example: filter_col = username, filter_val = &quot;grillus33&quot;, image_id == &quot;14190&quot; #&gt; # A tibble: 18 x 2 #&gt; image_id n #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 14191 5 #&gt; 2 14608 5 #&gt; 3 14623 5 #&gt; 4 14635 5 #&gt; 5 14654 5 #&gt; 6 14184 4 #&gt; 7 14190 4 #&gt; 8 14286 4 #&gt; 9 14358 4 #&gt; 10 14387 4 #&gt; 11 14470 4 #&gt; 12 14535 4 #&gt; 13 14132 3 #&gt; 14 14281 3 #&gt; 15 14329 3 #&gt; 16 14396 3 #&gt; 17 14469 3 #&gt; 18 14636 3 5.6.4 Multiple users annotations Example with image_id = 14190 gg_users_image(x = MAR_mussel_carto, image_id = 14190) Because we work with polygons, buffer is not totally necessary. However, just in case there are small areas, we can set a small buffer. gg_users_image(x = MAR_mussel_carto, image_id = 14190, buffer = 5) 5.7 Find all groups As shown for “Buccinides”, only one function is required to determine the differents groups of annotations in all images. This requires function find_groups_in_all_images, some time of computation and RAM available. # Chunk not evaluated in Rmd as results are saved MAR_mussel_carto_groups &lt;- MAR_mussel_carto %&gt;% find_groups_in_all_images(.progress = TRUE, keep_list = FALSE, as_sf = FALSE, dist_buffer = 5) if (!dir.exists(here::here(&quot;inst/outputs&quot;))) { dir.create(&quot;inst/outputs&quot;, recursive = TRUE) } readr::write_rds( MAR_mussel_carto_groups, here::here(&quot;inst/outputs&quot;, &quot;MAR_mussel_carto_groups.rds&quot;), compress = &quot;gz&quot;) outwd &lt;- system.file(&quot;outputs&quot;, package = &quot;deeptools&quot;) MAR_mussel_carto_groups &lt;- readr::read_rds(file.path(outwd, &quot;MAR_mussel_carto_groups.rds&quot;)) 5.8 Calculate statistics on images As a reminder, a group of objects is supposed to be a unique individual. 5.8.1 Number of objects per image (already known before) # Number of objects per image (already known before) mussel_nobjects &lt;- MAR_mussel_carto_groups %&gt;% count(image_id) %&gt;% rename(n_objects = n) %&gt;% count(n_objects) %&gt;% arrange(desc(n)) %&gt;% rename(n_images = n) # Number of marked objects by images mussel_nobjects #&gt; # A tibble: 24 x 2 #&gt; n_objects n_images #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 11 19 #&gt; 2 10 14 #&gt; 3 12 14 #&gt; 4 13 12 #&gt; 5 14 8 #&gt; 6 15 7 #&gt; 7 4 6 #&gt; 8 8 6 #&gt; 9 9 6 #&gt; 10 5 5 #&gt; # … with 14 more rows # Plot ggplot(mussel_nobjects) + geom_col(aes(x = n_objects, y = n_images), width = 1, fill = yellow, colour = grey) + ggtitle(&quot;Total number of objects identified in images&quot;) + xlab(&quot;Number of objects by image&quot;) + ylab(&quot;Number of images&quot;) + theme(panel.background = element_rect(fill = blue)) 5.8.2 Calculate surfaces of polygons We calculte the average and the standard deviation of groups MAR_mussel_carto_groups_area &lt;- MAR_mussel_carto_groups %&gt;% mutate(area = MAR_mussel_carto_groups %&gt;% st_sf() %&gt;% st_area()) %&gt;% group_by(image_id, group_kept) %&gt;% summarise(nb_polygons_in_group = n(), area_mean = mean(area), area_sd = sd(area), area_sd = if_else(is.na(area_sd), 0, area_sd), area_cv = area_sd / area_mean) %&gt;% arrange(desc(nb_polygons_in_group)) MAR_mussel_carto_groups_area #&gt; # A tibble: 1,508 x 6 #&gt; # Groups: image_id [133] #&gt; image_id group_kept nb_polygons_in_group area_mean area_sd area_cv #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 14186 1-16 2 1656. 211. 0.127 #&gt; 2 14186 11-20 2 176066. 41803. 0.237 #&gt; 3 14186 12-22 2 31141. 4061. 0.130 #&gt; 4 14186 13-23 2 5800. 4407. 0.760 #&gt; 5 14186 2-17 2 285. 159. 0.557 #&gt; 6 14186 3-15 2 2379. 89.4 0.0376 #&gt; 7 14186 4-18 2 1452 135. 0.0930 #&gt; 8 14186 5-26 2 823. 9.55 0.0116 #&gt; 9 14186 6-27 2 608. 319. 0.525 #&gt; 10 14186 7-14 2 8050 142. 0.0177 #&gt; # … with 1,498 more rows Graph of areas MAR_mussel_carto_groups_area %&gt;% ggplot() + geom_histogram(aes(area_mean), bins = 50, fill = yellow, colour = grey) + ggtitle(&quot;Average areas of groups identified in images&quot;) + xlab(&quot;Area (log scale)&quot;) + ylab(&quot;Number of groups&quot;) + theme(panel.background = element_rect(fill = blue)) + scale_x_log10() "],
["todo.html", "Chapter 6 TODO", " Chapter 6 TODO [x] to_carto_point() : ONC =&gt; “pycnogonide” [x] to_carto_polygon() : MAR =&gt; “couverture_de_moules” [x] Flip-y en paramètre [] Séparer l’analyse des images zoomées ou non zoomées. Influence sur le choix du buffer de comparaison [x] Choose statistics based on occurence threshold: If a group is found by only 1/5 users, do we remove it ? Do we have to define this threshold according to userlevel ? "],
["list-of-dependencies.html", "Chapter 7 List of dependencies", " Chapter 7 List of dependencies bookdown (Xie (2018a)) cowplot (Wilke (2018)) dplyr (Wickham, François, et al. (2018)) fasterize (Ross (2018)) forcats (Wickham (2018a)) furrr (Vaughan and Dancho (2018)) future (Bengtsson (2018)) ggplot2 (Wickham, Chang, et al. (2018)) ggrepel (Slowikowski (2018)) igraph (file. (2018)) knitr (Xie (2018b)) lubridate (Spinu, Grolemund, and Wickham (2018)) magrittr (Bache and Wickham (2014)) pkgdown (Wickham and Hesselberth (2018)) purrr (Henry and Wickham (2018)) raster (Hijmans (2018)) rasterVis (Perpinan Lamigueiro and Hijmans (2018)) readr (Wickham, Hester, and Francois (2017)) rlang (Henry and Wickham (2019)) rmarkdown (Allaire et al. (2018)) sf (Pebesma (2018)) stats ((???)) stringr (Wickham (2018b)) thinkr (Guyader and Rochette (2018)) tidyr (Wickham and Henry (2018)) utils ((???)) References "],
["references.html", "References", " References "]
]
